package com.monst.bankingplugin.persistence.repository;

import com.monst.bankingplugin.entity.log.AccountInterest;
import com.monst.bankingplugin.persistence.Query;
import org.bukkit.Bukkit;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.UUID;

public class AccountInterestRepository {
    
    public void createTable(Connection con) throws SQLException {
        Query.of("CREATE TABLE IF NOT EXISTS ACCOUNT_INTEREST("
                        + "interest_id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,"
                        + "account_id INTEGER NOT NULL REFERENCES ACCOUNT(account_id),"
                        + "bank_id INTEGER NOT NULL REFERENCES BANK(bank_id),"
                        + "recipient_uuid UUID NOT NULL,"
                        + "interest NUMERIC(16,2) NOT NULL,"
                        + "low_balance_fee NUMERIC(16,2) NOT NULL,"
                        + "final_payment NUMERIC(16,2) NOT NULL,"
                        + "timestamp TIMESTAMP)")
                .executeUpdate(con);
    }
    
    public void saveAll(Connection con, Collection<AccountInterest> accountInterests) throws SQLException {
        Query.of("INSERT INTO ACCOUNT_INTEREST "
                        + "(account_id, bank_id, recipient_uuid, interest, low_balance_fee, final_payment, timestamp) "
                        + "VALUES (?, ?, ?, ?, ?, ?, ?)")
                .batch(accountInterests)
                .with(this::deconstruct)
                .executeUpdate(con);
    }
    
    public List<AccountInterest> findByAccountID(Connection con, int accountID, int offset, int limit) throws SQLException {
        return Query.of("SELECT * FROM ACCOUNT_INTEREST WHERE account_id = ? ORDER BY interest_id DESC OFFSET ? ROWS LIMIT ?")
                .with(accountID, offset, limit)
                .asList(con, this::reconstruct);
    }
    
    public int countByAccountID(Connection con, int accountID) throws SQLException {
        return Query.of("SELECT COUNT(account_id) FROM ACCOUNT_INTEREST WHERE account_id = ?")
                .with(accountID)
                .asOne(con, Integer.class);
    }
    
    public BigDecimal getTotalInterestEarnedByPlayerSince(Connection con, UUID recipient, Timestamp since) throws SQLException {
        return Query.of("SELECT COALESCE(SUM(interest), 0) FROM ACCOUNT_INTEREST WHERE recipient_uuid = ? AND timestamp > ?")
                .with(recipient, since)
                .asOne(con, BigDecimal.class);
    }
    
    public BigDecimal getTotalLowBalanceFeesPaidByPlayerSince(Connection con, UUID recipient, Timestamp since) throws SQLException {
        return Query.of("SELECT COALESCE(SUM(low_balance_fee), 0) FROM ACCOUNT_INTEREST WHERE recipient_uuid = ? AND timestamp > ?")
                .with(recipient, since)
                .asOne(con, BigDecimal.class);
    }
    
    public void deleteBefore(Connection con, Timestamp oldest) throws SQLException {
        Query.of("DELETE FROM ACCOUNT_INTEREST WHERE timestamp < ?")
                .with(oldest)
                .executeUpdate(con);
    }
    
    private List<Object> deconstruct(AccountInterest interest) {
        return Arrays.asList(
                interest.getAccountID(),
                interest.getBankID(),
                interest.getRecipient().getUniqueId(),
                interest.getInterest(),
                interest.getLowBalanceFee(),
                interest.getFinalPayment(),
                Timestamp.from(interest.getInstant())
        );
    }
    
    private AccountInterest reconstruct(ResultSet rs, Connection con) throws SQLException {
        return new AccountInterest(
                rs.getInt("interest_id"),
                rs.getTimestamp("timestamp").toInstant(),
                rs.getInt("account_id"),
                rs.getInt("bank_id"),
                Bukkit.getOfflinePlayer(rs.getObject("recipient_uuid", UUID.class)),
                rs.getBigDecimal("interest"),
                rs.getBigDecimal("low_balance_fee")
        );
    }
    
}
