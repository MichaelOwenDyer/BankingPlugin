package com.monst.bankingplugin.persistence.repository;

import com.monst.bankingplugin.entity.log.BankIncome;
import com.monst.bankingplugin.persistence.Query;
import org.bukkit.Bukkit;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.*;

public class BankIncomeRepository {
    
    public void createTable(Connection con) throws SQLException {
        Query.of("CREATE TABLE IF NOT EXISTS BANK_INCOME("
                        + "income_id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,"
                        + "bank_id INTEGER NOT NULL REFERENCES BANK(bank_id),"
                        + "recipient_uuid UUID,"
                        + "revenue NUMERIC(16,2) NOT NULL,"
                        + "interest NUMERIC(16,2) NOT NULL,"
                        + "low_balance_fees NUMERIC(16,2) NOT NULL,"
                        + "net_income NUMERIC(16,2) NOT NULL,"
                        + "timestamp TIMESTAMP)")
                .executeUpdate(con);
    }
    
    public void saveAll(Connection con, Collection<BankIncome> bankIncomes) throws SQLException {
        Query.of("INSERT INTO BANK_INCOME "
                        + "(bank_id, recipient_uuid, revenue, interest, low_balance_fees, net_income, timestamp) "
                        + "VALUES (?, ?, ?, ?, ?, ?, ?)")
                .batch(bankIncomes)
                .with(this::deconstruct)
                .executeUpdate(con);
    }
    
    public int countByBankID(Connection con, int bankID) throws SQLException {
        return Query.of("SELECT COUNT(*) FROM BANK_INCOME WHERE bank_id = ?")
                .with(bankID)
                .asOne(con, Integer.class);
    }
    
    public List<BankIncome> findByBankID(Connection con, int bankID, int offset, int limit) throws SQLException {
        return Query.of("SELECT * FROM BANK_INCOME WHERE bank_id = ? ORDER BY income_id OFFSET ? ROWS LIMIT ?")
                .with(bankID, offset, limit)
                .asList(con, this::reconstruct);
    }
    
    public BigDecimal getTotalProfitOrLossByPlayerSince(Connection con, UUID recipientUUID, Timestamp since) throws SQLException {
        return Query.of("SELECT COALESCE(SUM(net_income), 0) FROM BANK_INCOME WHERE recipient_uuid = ? AND timestamp > ?")
                .with(recipientUUID, since)
                .asOne(con, BigDecimal.class);
    }
    
    public BigDecimal getTotalProfitOrLossAtBankSince(Connection con, int bankID, Timestamp since) throws SQLException {
        return Query.of("SELECT COALESCE(SUM(net_income), 0) FROM BANK_INCOME WHERE bank_id = ? AND timestamp > ?")
                .with(bankID, since)
                .asOne(con, BigDecimal.class);
    }
    
    public void deleteBefore(Connection con, Timestamp oldest) throws SQLException {
        Query.of("DELETE FROM BANK_INCOME WHERE timestamp < ?")
                .with(oldest)
                .executeUpdate(con);
    }
    
    private BankIncome reconstruct(ResultSet rs, Connection con) throws SQLException {
        return new BankIncome(
                rs.getInt("income_id"),
                rs.getTimestamp("timestamp").toInstant(),
                rs.getInt("bank_id"),
                Optional.ofNullable(rs.getObject("recipient_uuid", UUID.class))
                        .map(Bukkit::getOfflinePlayer).orElse(null),
                rs.getBigDecimal("revenue"),
                rs.getBigDecimal("interest"),
                rs.getBigDecimal("low_balance_fees"),
                rs.getBigDecimal("net_income")
        );
    }
    
    private List<Object> deconstruct(BankIncome bankIncome) {
        return Arrays.asList(
                bankIncome.getBankID(),
                bankIncome.getRecipient().getUniqueId(),
                bankIncome.getRevenue(),
                bankIncome.getInterest(),
                bankIncome.getLowBalanceFees(),
                bankIncome.getNetIncome(),
                Timestamp.from(bankIncome.getInstant())
        );
    }
    
}
